__version__ = "1.0.0"
__author__ = "PlanX Lab Development Team"

from . import (
    utime, math,
    machine, micropython
)


class MPU6050:
    _RA_SMPLRT_DIV      = 0x19
    _RA_CONFIG          = 0x1A
    _RA_GYRO_CONFIG     = 0x1B
    _RA_ACCEL_CONFIG    = 0x1C
    _RA_FIFO_EN         = 0x23
    _RA_INT_ENABLE      = 0x38
    _RA_INT_STATUS      = 0x3A
    _RA_ACCEL_XOUT_H    = 0x3B
    _RA_TEMP_OUT_H      = 0x41
    _RA_GYRO_XOUT_H     = 0x43
    _RA_SIGNAL_PATH_RST = 0x68
    _RA_USER_CTRL       = 0x6A
    _RA_PWR_MGMT_1      = 0x6B
    _RA_PWR_MGMT_2      = 0x6C
    _RA_BANK_SEL        = 0x6D
    _RA_MEM_START_ADDR  = 0x6E
    _RA_MEM_R_W         = 0x6F
    _RA_FIFO_COUNTH     = 0x72
    _RA_FIFO_R_W        = 0x74
    _RA_WHO_AM_I        = 0x75

    _BIT_DMP_EN         = 7
    _BIT_FIFO_EN        = 6
    _BIT_DMP_RST        = 3
    _BIT_FIFO_RST       = 2

    _ACC_LSB_PER_G      = 4096.0      # ±8g
    _GYR_LSB_PER_DPS    = 16.4        # ±2000 dps
    _DMP_PACKET_SIZE    = 42          # include quaternion (16 bytes)

    _RA_DMP_CFG_1 = 0x70
    _RA_DMP_CFG_2 = 0x71

    _DMP_FW_BYTES = bytes([
        # bank 0, 256 bytes
        0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
        0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
        0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
        0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
        0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

        # bank 1, 256 bytes
        0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
        0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
        0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
        0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

        # bank 2, 256 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        # bank 3, 256 bytes
        0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
        0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
        0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
        0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
        0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
        0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
        0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
        0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
        0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
        0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
        0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
        0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
        0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
        0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
        0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
        0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

        # bank 4, 256 bytes
        0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
        0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
        0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
        0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
        0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
        0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
        0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
        0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
        0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
        0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
        0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
        0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
        0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
        0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
        0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
        0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

        # bank 5, 256 bytes
        0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
        0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
        0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
        0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
        0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
        0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
        0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
        0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
        0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
        0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
        0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
        0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
        0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
        0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
        0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
        0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

        # bank 6, 256 bytes
        0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
        0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
        0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
        0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
        0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
        0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
        0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
        0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
        0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
        0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
        0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
        0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
        0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
        0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
        0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
        0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

        # bank 7, 138 bytes (remainder)
        0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
        0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
        0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
        0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
        0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
        0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
        0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
        0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
    ])

    _DMP_CFG_BYTES = bytes([
        # [BANK, OFFSET, LENGTH, <DATA...>]
        0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C,
        0x03, 0xAB, 0x03, 0x36, 0x56, 0x76,
        0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2,
        0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1,
        0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
        0x03, 0x89, 0x03, 0x26, 0x46, 0x66,
        0x00, 0x6C, 0x02, 0x20, 0x00,
        0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00,
        0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
        0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D,
        0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D,
        0x00, 0xA3, 0x01, 0x00,

        # SPECIAL 0x01 = enable interrupts  (bank=0, offset=0, length=0, data=0x01)
        0x00, 0x00, 0x00, 0x01,

        0x07, 0x86, 0x01, 0xFE,
        0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38,
        0x07, 0x7E, 0x01, 0x30,
        0x07, 0x46, 0x01, 0x9A,
        0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38,
        0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38,
        0x02, 0x16, 0x02, 0x00, 0x01
    ])

    _DMP_UPD_BYTES = bytes([
        0x01, 0xB2, 0x02, 0xFF, 0xFF,
        0x01, 0x90, 0x04, 0x09, 0x23, 0xA1, 0x35,
        0x01, 0x6A, 0x02, 0x06, 0x00,
        0x01, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
        0x01, 0x62, 0x02, 0x00, 0x00,
        0x00, 0x60, 0x04, 0x00, 0x40, 0x00, 0x00
    ])

    DLPF_DIV8K_256HZ       = 0   # Minimum filtering, 8kHz internal sample rate
    DLPF_DIV1K_98HZ        = 2   # Stronger filtering, 1kHz internal sample rate
    DLPF_DIV1K_42HZ        = 3   # Even stronger filtering, 1kHz internal sample rate
    SIMPLERT_DIV8K_1KHz    = 7
    SIMPLERT_DIV1K_200Hz   = 4
    SIMPLERT_DIV1K_100Hz   = 9

    class Mode:
        DMP_STABLE   = "dmp_stable"
        DMP_FAST     = "dmp_fast"
        RAW_BALANCED = "raw_balanced"
        RAW_FAST     = "raw_fast"

    _MODE_PRESETS = {
        Mode.DMP_STABLE:   (DLPF_DIV1K_42HZ,  SIMPLERT_DIV1K_100Hz, True),
        Mode.DMP_FAST:     (DLPF_DIV1K_98HZ,  SIMPLERT_DIV1K_200Hz, True),
        Mode.RAW_BALANCED: (DLPF_DIV1K_42HZ,  SIMPLERT_DIV1K_200Hz, False),
        Mode.RAW_FAST:     (DLPF_DIV8K_256HZ, SIMPLERT_DIV8K_1KHz,  False),
    }

    def __init__(self, scl, sda, *, addr=0x68, mode=Mode.RAW_BALANCED):
        self._i2c = ticle.I2c(scl=scl, sda=sda, addr=addr)
        self._pkt_size = int(self._DMP_PACKET_SIZE)

        self._heading_offset = 0.0
        
        # Reset and Wake up
        self._i2c.writeto_mem(self._RA_PWR_MGMT_1, bytes([0x80])); utime.sleep_ms(100)
        self._i2c.writeto_mem(self._RA_SIGNAL_PATH_RST, bytes([0x07])); utime.sleep_ms(10)
        self._i2c.writeto_mem(self._RA_PWR_MGMT_1, bytes([0x01]))
        self._i2c.writeto_mem(self._RA_PWR_MGMT_2, bytes([0x00])); utime.sleep_ms(10)
        
        who = self._i2c.readfrom_mem(self._RA_WHO_AM_I, 1)[0]
        if who not in (0x68, 0x69, 0x70):
            raise RuntimeError(f"MPU6050 not found (WHO_AM_I=0x{who:02X})")
        
        if mode not in self._MODE_PRESETS:
            raise ValueError("Unknown mode: %r" % (mode,))
        dlpf, smplrt_div, use_dmp = self._MODE_PRESETS[mode]
        self._use_dmp = bool(use_dmp)
        
        self._i2c.writeto_mem(self._RA_CONFIG, bytes([dlpf]))                           
        cur = self._i2c.readfrom_mem(self._RA_GYRO_CONFIG, 1)[0]
        self._i2c.writeto_mem(self._RA_GYRO_CONFIG, bytes([(cur & ~0x18) | (3 << 3)]))  # ±2000 dps
        cur = self._i2c.readfrom_mem(self._RA_ACCEL_CONFIG, 1)[0]
        self._i2c.writeto_mem(self._RA_ACCEL_CONFIG, bytes([(cur & ~0x18) | (2 << 3)])) # ±8 g
        self._i2c.writeto_mem(self._RA_SMPLRT_DIV, bytes([smplrt_div]))                 
        
        # Disable INT/FIFO/DMP initially
        self._i2c.writeto_mem(self._RA_INT_ENABLE, bytes([0x00]))
        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([0x00]))
        self._i2c.writeto_mem(self._RA_FIFO_EN, bytes([0x00]))

        self._acc_bias = [0.0, 0.0, 0.0]
        self._gyr_bias = [0.0, 0.0, 0.0]
        self._buf6  = bytearray(6)
        self._buf14 = bytearray(14)
        self._buf42 = bytearray(self._pkt_size)

        self._quick_bias()

        if self._use_dmp:
            self._load_dmp_firmware()
            self._flush_fifo()
            self._wait_for_dmp_packet()
            self.zero_heading()
        
        self._timeout_ms = 150
        self._cb = None
        self._tmr = None
        self._poll_busy = False
        self._scheduled = False

    def deinit(self):
        self.on_read = None
        self._i2c.writeto_mem(self._RA_INT_ENABLE, bytes([0x00]))
        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([0x00]))
        self._i2c.writeto_mem(self._RA_FIFO_EN, bytes([0x00]))
        utime.sleep_ms(10)
        self._chb = None
        self._i2c.writeto_mem(self._RA_PWR_MGMT_1, bytes([0x40]))
        self._i2c.deinit()
        self._i2c = None
        
    @property
    def on_read(self):
        return self._cb

    @on_read.setter
    def on_read(self, func):
        self._cb = func
        if func and not self._tmr:
            self._tmr = machine.Timer(-1)
            self._tmr.init(period=5, mode=machine.Timer.PERIODIC, callback=self._tmr_isr)
        elif not func and self._tmr:
            self._tmr.deinit()
            self._tmr = None
            self._scheduled = False

    def read(self) -> tuple["accel", "gyro", "quaternion", "euler", "linear"]:
        ax, ay, az = self.accel
        gx, gy, gz = self.gyro
        if not self._use_dmp:
            return (ax, ay, az), (gx, gy, gz), (1.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0), (0.0, 0.0, 0.0)
        
        # DMP mode snapshot
        q = self.quaternion
        roll, pitch, yaw = self._quat_to_euler(q)
        if self._heading_offset != 0.0:
            yaw -= self._heading_offset
            if yaw > math.pi: yaw -= 2*math.pi
            if yaw < -math.pi: yaw += 2*math.pi
        R = self._rotmat_from_quat_wxyz(q)
        axw = R[0][0]*ax + R[0][1]*ay + R[0][2]*az
        ayw = R[1][0]*ax + R[1][1]*ay + R[1][2]*az
        azw = R[2][0]*ax + R[2][1]*ay + R[2][2]*az - 1.0

        return (ax, ay, az), (gx, gy, gz), q, (roll, pitch, yaw), (axw, ayw, azw)

    @property
    def accel(self):
        self._i2c.readfrom_mem_into(self._RA_ACCEL_XOUT_H, self._buf6)
        b = self._buf6
        ax = self._twos16(b[0],b[1]); ay = self._twos16(b[2],b[3]); az = self._twos16(b[4],b[5])
        axg, ayg, azg = ax/self._ACC_LSB_PER_G, ay/self._ACC_LSB_PER_G, az/self._ACC_LSB_PER_G
        return axg - self._acc_bias[0], ayg - self._acc_bias[1], azg - self._acc_bias[2]
    
    @property
    def gyro(self):
        self._i2c.readfrom_mem_into(self._RA_GYRO_XOUT_H, self._buf6)
        b = self._buf6
        gx = self._twos16(b[0],b[1]); gy = self._twos16(b[2],b[3]); gz = self._twos16(b[4],b[5])
        gxd, gyd, gzd = gx/self._GYR_LSB_PER_DPS, gy/self._GYR_LSB_PER_DPS, gz/self._GYR_LSB_PER_DPS
        return gxd - self._gyr_bias[0], gyd - self._gyr_bias[1], gzd - self._gyr_bias[2]

    @property
    def quaternion(self):
        if not self._use_dmp:
            return (1.0, 0.0, 0.0, 0.0)
        
        t0 = utime.ticks_ms()
        while True:
            st = self._int_status()
            if st & 0x10:  # FIFO overflow
                self._flush_fifo()
            elif st & 0x02:  # DMP data-ready interrupt
                break

            if self._fifo_count_direct() >= self._pkt_size:
                break

            if utime.ticks_diff(utime.ticks_ms(), t0) >= self._timeout_ms:
                raise RuntimeError("No DMP packet ready")
            utime.sleep_ms(1)

        cnt = self._fifo_count_direct()
        rem = cnt % self._pkt_size
        if rem:
            _ = self._fifo_read_direct(rem)
            cnt -= rem

        while cnt > self._pkt_size:
            _ = self._fifo_read_direct(self._pkt_size)
            cnt -= self._pkt_size

        pkt = self._fifo_read_direct(self._pkt_size)
        if len(pkt) != self._pkt_size:
            raise RuntimeError("Short DMP packet")

        q0 = self._twos32(pkt[0],  pkt[1],  pkt[2],  pkt[3])
        q1 = self._twos32(pkt[4],  pkt[5],  pkt[6],  pkt[7])
        q2 = self._twos32(pkt[8],  pkt[9],  pkt[10], pkt[11])
        q3 = self._twos32(pkt[12], pkt[13], pkt[14], pkt[15])
        if not (q0 | q1 | q2 | q3):
            if self._wait_for_dmp_packet(self._timeout_ms):
                return self.quaternion
            return (1.0, 0.0, 0.0, 0.0)
        
        s = 1.0 / (1 << 30)
        q = self._q_normalize((q0*s, q1*s, q2*s, q3*s)) 
        
        return q

    @property
    def euler(self):
        if not self._use_dmp:
            return 0.0, 0.0, 0.0
        
        roll, pitch, yaw = self._quat_to_euler(self.quaternion)
        
        if self._heading_offset != 0.0:
            yaw -= self._heading_offset
            if yaw >  math.pi: yaw -= 2*math.pi
            if yaw < -math.pi: yaw += 2*math.pi

        return roll, pitch, yaw

    @property
    def linear(self):
        if not self._use_dmp:
            return (0.0, 0.0, 0.0)
        
        ax, ay, az = self.accel
        q = self.quaternion
        R = self._rotmat_from_quat_wxyz(q)
        axw = R[0][0]*ax + R[0][1]*ay + R[0][2]*az
        ayw = R[1][0]*ax + R[1][1]*ay + R[1][2]*az
        azw = R[2][0]*ax + R[2][1]*ay + R[2][2]*az
        return (axw, ayw, azw - 1.0)
    
    def zero_heading(self):
        _, _, yaw = self.euler
        self._heading_offset = yaw

    def _int_status(self):
        return self._i2c.readfrom_mem(self._RA_INT_STATUS, 1)[0]

    def _flush_fifo(self):
        user = self._i2c.readfrom_mem(self._RA_USER_CTRL, 1)[0]
        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([user | (1<<self._BIT_FIFO_RST)]))
        utime.sleep_ms(2)

    def _wait_for_dmp_packet(self, timeout_ms=150):
        t0 = utime.ticks_ms()
        while utime.ticks_diff(utime.ticks_ms(), t0) < timeout_ms:
            if self._fifo_count_direct() >= self._pkt_size:
                return True
        return False

    def _load_dmp_firmware(self, fw=None, cfg=None, upd=None):
        fw  = fw  if fw  is not None else self._DMP_FW_BYTES
        cfg = cfg if cfg is not None else self._DMP_CFG_BYTES
        upd = upd if upd is not None else self._DMP_UPD_BYTES

        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([(1<<self._BIT_DMP_RST) | (1<<self._BIT_FIFO_RST)]))
        utime.sleep_ms(10)

        self._write_memory_block_direct(fw, bank=0, address=0)
        self._write_config_set_direct(cfg)
        self._write_config_set_direct(upd)
        
        self._i2c.writeto_mem(self._RA_DMP_CFG_1, bytes([0x03]))
        self._i2c.writeto_mem(self._RA_DMP_CFG_2, bytes([0x00]))

        user = self._i2c.readfrom_mem(self._RA_USER_CTRL, 1)[0]
        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([user | (1<<self._BIT_FIFO_RST)]))
        utime.sleep_ms(5)

        user |= (1<<self._BIT_DMP_EN) | (1<<self._BIT_FIFO_EN)
        self._i2c.writeto_mem(self._RA_USER_CTRL, bytes([user]))
        self._i2c.writeto_mem(self._RA_FIFO_EN, bytes([0x00]))
        
        self._pkt_size = int(self._DMP_PACKET_SIZE)
        return True
    
    def _select_bank_direct(self, bank):
        self._i2c.writeto_mem(self._RA_BANK_SEL, bytes([bank & 0x1F]))

    def _set_mem_addr_direct(self, addr):
        self._i2c.writeto_mem(self._RA_MEM_START_ADDR, bytes([addr & 0xFF]))

    def _write_memory_block_direct(self, data: bytes, bank=0, address=0, chunk=16):
        i = 0
        L = len(data)
        while i < L:
            self._select_bank_direct(bank)
            self._set_mem_addr_direct(address)
            space = 256 - address
            this = min(chunk, space, L - i)
            self._i2c.writeto_mem(self._RA_MEM_R_W, data[i:i+this])
            i += this
            address += this
            if address == 256:
                bank += 1
                address = 0

    def _write_config_set_direct(self, cfg: bytes):
        i, L = 0, len(cfg)
        while i < L:
            if i + 3 > L:
                raise ValueError("Malformed DMP config (truncated header)")
            bank   = cfg[i]; offset = cfg[i+1]; length = cfg[i+2]; i += 3

            if length == 0:
                if i >= L:
                    raise ValueError("Malformed DMP config (missing special code)")
                special = cfg[i]; i += 1
                if special == 0x01:
                    self._i2c.writeto_mem(self._RA_INT_ENABLE, bytes([0x02]))  # DMP INT
                continue

            if i + length > L:
                raise ValueError("Malformed DMP config (length overflow)")
            self._write_memory_block_direct(cfg[i:i+length], bank=bank, address=offset)
            i += length

    def _fifo_count_direct(self):
        b = self._i2c.readfrom_mem(self._RA_FIFO_COUNTH, 2)
        return (b[0] << 8) | b[1]

    def _fifo_read_direct(self, n):
        mv = memoryview(self._buf42)[:n]
        self._i2c.readfrom_mem_into(self._RA_FIFO_R_W, mv)
        return mv

    def _quick_bias(self, n=200, delay_ms=2):
        ax = ay = az = gx = gy = gz = 0.0

        for _ in range(20):
            _ = self._i2c.readfrom_mem(self._RA_ACCEL_XOUT_H, 14); utime.sleep_ms(1)

        for _ in range(n):
            b = self._i2c.readfrom_mem(self._RA_ACCEL_XOUT_H, 14)
            ax += self._twos16(b[0],b[1]) 
            ay += self._twos16(b[2],b[3]) 
            az += self._twos16(b[4],b[5])
            gx += self._twos16(b[8],b[9])  
            gy += self._twos16(b[10],b[11])
            gz += self._twos16(b[12],b[13])
            utime.sleep_ms(delay_ms)
        inv = 1.0/n
        axg, ayg, azg = (ax*inv)/self._ACC_LSB_PER_G, (ay*inv)/self._ACC_LSB_PER_G, (az*inv)/self._ACC_LSB_PER_G
        gxd, gyd, gzd = (gx*inv)/self._GYR_LSB_PER_DPS, (gy*inv)/self._GYR_LSB_PER_DPS, (gz*inv)/self._GYR_LSB_PER_DPS
        self._acc_bias = [axg, ayg, azg - 1.0]
        self._gyr_bias = [gxd, gyd, gzd]

    def _tmr_isr(self, t):
        if self._poll_busy or not self._cb or self._scheduled:
            return

        self._scheduled = True
        try:
            micropython.schedule(self._poll_sched, 0)
        except Exception:
            self._scheduled = False

    def _has_dmp_packet(self):
        return (self._i2c.readfrom_mem(self._RA_INT_STATUS, 1)[0] & 0x02) or (self._fifo_count_direct() >= self._pkt_size)

    def _read_quat_once(self):
        if not self._use_dmp:
            return (1.0, 0.0, 0.0, 0.0)
        
        st = self._int_status()
        if st & 0x10:          # FIFO overflow
            self._flush_fifo()
            return None

        cnt = self._fifo_count_direct()
        if cnt < self._pkt_size:
            return None

        rem = cnt % self._pkt_size
        if rem:
            self._fifo_read_direct(rem)
            cnt -= rem

        while cnt > self._pkt_size:
            self._fifo_read_direct(self._pkt_size)
            cnt -= self._pkt_size

        pkt = self._fifo_read_direct(self._pkt_size)
        if len(pkt) != self._pkt_size:
            return None

        q0 = self._twos32(pkt[0],  pkt[1],  pkt[2],  pkt[3])
        q1 = self._twos32(pkt[4],  pkt[5],  pkt[6],  pkt[7])
        q2 = self._twos32(pkt[8],  pkt[9],  pkt[10], pkt[11])
        q3 = self._twos32(pkt[12], pkt[13], pkt[14], pkt[15])

        s = 1.0 / (1 << 30)
        return self._q_normalize((q0*s, q1*s, q2*s, q3*s))

    def _poll_sched(self, _):
        self._scheduled = False
        if self._poll_busy or not self._cb:
            return
        self._poll_busy = True
        try:
            if self._use_dmp:
                q = self._read_quat_once()
                if q is None:
                    return
                
            try:
                self._cb(*self.read())
            except Exception as e:
                import sys
                sys.print_exception(e)
        except Exception as e:
            import sys
            sys.print_exception(e)
        finally:
            self._poll_busy = False

    @staticmethod
    def _quat_to_euler(q):
        w, x, y, z = q
        roll = math.atan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))
        sp = 2*(w*y - z*x)
        sp = -1.0 if sp < -1.0 else (1.0 if sp > 1.0 else sp)
        pitch = math.asin(sp)
        yaw = math.atan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))
        return roll, pitch, yaw

    @staticmethod
    def _q_normalize(q):
        w, x, y, z = q
        n2 = w*w + x*x + y*y + z*z
        if n2 <= 0.0:
            return (1.0, 0.0, 0.0, 0.0)
        n = math.sqrt(n2)
        return (w/n, x/n, y/n, z/n)

    @staticmethod
    def _q_mul(a, b):
        aw, ax, ay, az = a
        bw, bx, by, bz = b
        return (
            aw*bw - ax*bx - ay*by - az*bz,
            aw*bx + ax*bw + ay*bz - az*by,
            aw*by - ax*bz + ay*bw + az*bx,
            aw*bz + ax*by - ay*bx + az*bw,
        )

    @staticmethod
    def _rotmat_from_quat_wxyz(q):
        w,x,y,z = q
        xx,yy,zz = x*x,y*y,z*z
        wx,wy,wz = w*x,w*y,w*z
        xy,xz,yz = x*y,x*z,y*z
        return [
            [1-2*(yy+zz), 2*(xy-wz),   2*(xz+wy)],
            [2*(xy+wz),   1-2*(xx+zz), 2*(yz-wx)],
            [2*(xz-wy),   2*(yz+wx),   1-2*(xx+yy)],
        ]

    @staticmethod
    def _twos16(h, l):
        v = (h << 8) | l
        return v - 0x10000 if v & 0x8000 else v

    @staticmethod
    def _twos32(b0, b1, b2, b3):
        v = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        if v & 0x80000000:
            v = -((~v & 0xFFFFFFFF) + 1)
        return v
